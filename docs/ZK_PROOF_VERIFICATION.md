# Zero-Knowledge Proof Verification for Observers

This document explains how election observers and the public can verify the cryptographic proofs generated by the FHE voting system without compromising voter privacy.

## Table of Contents

1. [Overview](#overview)
2. [Proof Types](#proof-types)
3. [Verification Process](#verification-process)
4. [Public Verification Tools](#public-verification-tools)
5. [Verification API](#verification-api)
6. [Interpreting Results](#interpreting-results)
7. [Common Questions](#common-questions)

## Overview

### What Are Zero-Knowledge Proofs?

Zero-knowledge proofs (ZKPs) allow one party to prove a statement is true without revealing any information beyond the validity of the statement itself.

In the context of voting:
- **Ballot Validity**: Proves a vote is for a valid candidate without revealing which candidate
- **Voter Eligibility**: Proves a voter is registered without revealing their identity
- **Tally Correctness**: Proves the final count is correct without revealing individual votes

### Why Verification Matters

Public verification ensures:
1. **Transparency**: Anyone can verify the election was conducted correctly
2. **Trust**: No need to trust election officials or software
3. **Privacy**: Verification reveals nothing about individual votes
4. **Integrity**: Tampering would be mathematically detectable

## Proof Types

### 1. Bulletproofs (Ballot Validity)

**Purpose**: Proves that an encrypted ballot contains a valid choice (e.g., a number between 0 and N-1 for N candidates).

**What it proves**:
- The encrypted value is within the valid range
- The voter selected exactly one candidate (or valid number of candidates)

**What it does NOT reveal**:
- Which candidate was selected
- Any information about the voter

**Proof size**: ~700 bytes

### 2. Groth16 (Voter Eligibility)

**Purpose**: Proves that a voter is in the registered voter list without revealing their identity.

**What it proves**:
- The voter's commitment is in the Merkle tree of registered voters
- The voter has not voted before (nullifier uniqueness)

**What it does NOT reveal**:
- The voter's identity
- The voter's position in the registry

**Proof size**: ~200 bytes

### 3. PLONK (Tally Correctness)

**Purpose**: Proves that the final tally was computed correctly from all encrypted ballots.

**What it proves**:
- The homomorphic sum was computed correctly
- No ballots were added, removed, or modified
- The decryption was performed correctly

**What it does NOT reveal**:
- Individual vote values
- Intermediate computation states

**Proof size**: ~400 bytes

## Verification Process

### Step 1: Obtain Verification Package

Download the election verification package from the official election website:

```bash
# Download verification package
curl -O https://election.gov/2024/verification-package.zip

# Verify package signature
gpg --verify verification-package.zip.sig verification-package.zip

# Extract package
unzip verification-package.zip
```

The package contains:
- `election_config.json` - Election parameters
- `public_key.bin` - Election public key
- `merkle_root.bin` - Voter registry Merkle root
- `proofs/` - Directory of all ZK proofs
- `audit_trail.json` - Cryptographic audit log
- `final_tally.json` - Encrypted and decrypted results
- `verification_keys/` - ZK verification keys

### Step 2: Verify Election Configuration

```typescript
import { PublicVerifier } from '@digitaldefiance/node-fhe-accelerate';

const verifier = new PublicVerifier();

// Load election configuration
const config = JSON.parse(fs.readFileSync('election_config.json', 'utf-8'));
const result = verifier.verifyConfig(config);

console.log('Election:', config.name);
console.log('Candidates:', config.candidates);
console.log('Security Level:', config.securityLevel);
console.log('Threshold:', `${config.threshold} of ${config.totalOfficials}`);
console.log('Config Valid:', result.valid);
```

### Step 3: Verify Ballot Proofs

```typescript
import { PublicVerifier, type BallotProofEntry } from '@digitaldefiance/node-fhe-accelerate';
import * as fs from 'fs';

const verifier = new PublicVerifier();

// Load ballot proofs
const ballotProofs: BallotProofEntry[] = JSON.parse(
  fs.readFileSync('proofs/ballots.json', 'utf-8')
);
const config = JSON.parse(fs.readFileSync('election_config.json', 'utf-8'));

console.log(`Verifying ${ballotProofs.length} ballot proofs...`);

const result = await verifier.verifyBallotProofs(
  ballotProofs,
  config.candidates.length,
  (progress) => {
    console.log(`Progress: ${progress.percent}%`);
  }
);

console.log(`\nBallot Verification Results:`);
console.log(`  Valid: ${result.details.validProofs}`);
console.log(`  Invalid: ${result.details.invalidProofs}`);

if (result.errors.length > 0) {
  console.log('Errors:');
  result.errors.forEach(err => console.log(`  - ${err}`));
}
```

### Step 4: Verify Eligibility Proofs

```typescript
import { PublicVerifier, type EligibilityProofEntry } from '@digitaldefiance/node-fhe-accelerate';

const verifier = new PublicVerifier();

// Load Merkle root and eligibility proofs
const config = JSON.parse(fs.readFileSync('election_config.json', 'utf-8'));
const eligibilityProofs: EligibilityProofEntry[] = JSON.parse(
  fs.readFileSync('proofs/eligibility.json', 'utf-8')
);

console.log(`Verifying ${eligibilityProofs.length} eligibility proofs...`);

const result = await verifier.verifyEligibilityProofs(
  eligibilityProofs,
  config.merkleRoot,
  (progress) => {
    console.log(`Progress: ${progress.percent}%`);
  }
);

console.log(`\nEligibility Verification Results:`);
console.log(`  Valid: ${result.details.validProofs}`);
console.log(`  Invalid: ${result.details.invalidProofs}`);
console.log(`  Unique Voters: ${result.details.uniqueVoters}`);
```

### Step 5: Verify Tally Correctness

```typescript
import { 
  PublicVerifier, 
  type TallyCorrectnessProof,
  type FinalTally 
} from '@digitaldefiance/node-fhe-accelerate';

const verifier = new PublicVerifier();

// Load tally proof and final results
const tallyProof: TallyCorrectnessProof = JSON.parse(
  fs.readFileSync('proofs/tally_correctness.json', 'utf-8')
);
const finalTally: FinalTally = JSON.parse(
  fs.readFileSync('final_tally.json', 'utf-8')
);
const config = JSON.parse(fs.readFileSync('election_config.json', 'utf-8'));

// Verify tally correctness
const tallyResult = verifier.verifyTallyProof(tallyProof, finalTally);

console.log('\nTally Verification:');
console.log(`  Valid: ${tallyResult.valid}`);
console.log(`  Total Ballots: ${finalTally.totalBallots}`);
console.log(`  Verification Time: ${tallyResult.verificationTimeMs}ms`);

if (tallyResult.valid) {
  console.log('\nFinal Results:');
  finalTally.decryptedCounts.forEach((count, i) => {
    console.log(`  ${config.candidates[i]}: ${count} votes`);
  });
}
```

### Step 6: Verify Audit Trail

```typescript
import { PublicVerifier, type AuditEntry } from '@digitaldefiance/node-fhe-accelerate';

const verifier = new PublicVerifier();

// Load and verify audit trail
const auditTrail: AuditEntry[] = JSON.parse(
  fs.readFileSync('audit_trail.json', 'utf-8')
);
const auditResult = verifier.verifyAuditTrail(auditTrail);

console.log('\nAudit Trail Verification:');
console.log(`  Valid: ${auditResult.valid}`);
console.log(`  Entries: ${auditResult.details.entriesVerified}`);
console.log(`  Chain Integrity: ${auditResult.details.chainValid ? 'OK' : 'BROKEN'}`);

if (auditResult.errors.length > 0) {
  console.log('Errors:');
  auditResult.errors.forEach(err => console.log(`  - ${err}`));
}
```

## Public Verification Tools

### Command-Line Verifier

The library includes a verification CLI:

```bash
# Install the library globally
npm install -g @digitaldefiance/node-fhe-accelerate

# Run verification using the CLI
npx fhe-verify --package verification-package.json

# Verify specific components
npx fhe-verify --audit audit_trail.json

# Generate verification report
npx fhe-verify --package verification-package.json --report report.html --format html

# Verbose output
npx fhe-verify --package verification-package.json --verbose
```

### Web-Based Verifier

Visit the public verification portal:

```
https://verify.election.gov/2024
```

Features:
- Upload verification package
- Real-time verification progress
- Detailed verification report
- Downloadable verification certificate

### Docker Verifier

For isolated verification:

```bash
# Build verifier image from the library
docker build -t fhe-voting-verifier .

# Run verification
docker run -v $(pwd)/verification-package:/data \
  fhe-voting-verifier \
  npx fhe-verify --package /data/verification-package.json
```


## Verification API

### Using the PublicVerifier Class

The library provides a `PublicVerifier` class for programmatic verification:

```typescript
import { 
  PublicVerifier, 
  generateHTMLReport,
  exportReportJSON,
  type VerificationPackage 
} from '@digitaldefiance/node-fhe-accelerate';

const verifier = new PublicVerifier();

// Load your verification package
const pkg: VerificationPackage = JSON.parse(
  fs.readFileSync('verification-package.json', 'utf-8')
);

// Run full verification with progress callback
const report = await verifier.verifyAll(pkg, (progress) => {
  console.log(`${progress.stage}: ${progress.percent}%`);
});

console.log('Overall valid:', report.overallValid);
console.log('Summary:', report.summary);

// Generate reports
const htmlReport = generateHTMLReport(report);
const jsonReport = exportReportJSON(report);

fs.writeFileSync('report.html', htmlReport);
fs.writeFileSync('report.json', jsonReport);
```

### TypeScript/JavaScript SDK

```typescript
import { 
  PublicVerifier,
  generateHTMLReport,
  type VerificationPackage,
  type VerificationReport 
} from '@digitaldefiance/node-fhe-accelerate';

// Create verifier instance
const verifier = new PublicVerifier();

// Verify a specific ballot proof
const ballotResult = verifier.verifyBallotValidityProof(proof, numCandidates);
console.log('Ballot valid:', ballotResult.valid);

// Verify all proofs in a package
const pkg: VerificationPackage = loadVerificationPackage();
const report: VerificationReport = await verifier.verifyAll(pkg, (progress) => {
  console.log(`Progress: ${progress.percent}%`);
});

console.log('Full verification:', report.overallValid);
console.log('Ballots verified:', report.ballotVerification.details.totalBallots);
```

### Python Example (Using Node.js Subprocess)

For Python users, you can call the verification CLI:

```python
import subprocess
import json

def verify_election(package_path: str) -> dict:
    """Verify an election using the fhe-verify CLI."""
    result = subprocess.run(
        ['npx', 'fhe-verify', '--package', package_path, '--format', 'json'],
        capture_output=True,
        text=True
    )
    
    if result.returncode == 0:
        return {'valid': True, 'output': result.stdout}
    else:
        return {'valid': False, 'error': result.stderr}

# Usage
result = verify_election('verification-package.json')
print(f"Verification result: {'VALID' if result['valid'] else 'INVALID'}")
```

## Interpreting Results

### Successful Verification

```
=== Election Verification Report ===

Election: General Election 2024
Election ID: election-2024-general
Verification Date: 2024-11-06T10:30:00Z

Configuration Verification: ✓ PASSED
  - Security level: 128-bit
  - Threshold: 3 of 5
  - Candidates: 4

Ballot Verification: ✓ PASSED
  - Total ballots: 150,000
  - Valid proofs: 150,000
  - Invalid proofs: 0
  - Verification time: 45.2 seconds

Eligibility Verification: ✓ PASSED
  - Unique voters: 150,000
  - Merkle proofs valid: 150,000
  - Duplicate attempts: 0

Tally Verification: ✓ PASSED
  - Homomorphic sum: CORRECT
  - Decryption: CORRECT
  - Proof valid: YES

Audit Trail Verification: ✓ PASSED
  - Entries: 450,123
  - Chain integrity: VALID
  - Signatures: VALID

OVERALL RESULT: ✓ ELECTION VERIFIED
```

### Failed Verification

```
=== Election Verification Report ===

Election: General Election 2024
Verification Date: 2024-11-06T10:30:00Z

Ballot Verification: ✗ FAILED
  - Total ballots: 150,000
  - Valid proofs: 149,998
  - Invalid proofs: 2
  
  ERRORS:
  - Ballot ballot-78901: Range proof verification failed
    Reason: Commitment does not match claimed range
  - Ballot ballot-89012: Invalid proof structure
    Reason: Missing inner product proof component

OVERALL RESULT: ✗ VERIFICATION FAILED

ACTION REQUIRED: Contact election officials for investigation.
```

### Verification Warnings

```
=== Election Verification Report ===

Ballot Verification: ✓ PASSED (with warnings)

WARNINGS:
- 3 ballots have proofs generated with older library version
  Affected: ballot-12345, ballot-23456, ballot-34567
  Impact: None - proofs are still valid
  
- Verification took longer than expected (2.5x baseline)
  Possible cause: High system load during verification
  Impact: None - results are still valid
```

## Common Questions

### Q: Can I verify my own vote?

**A**: You can verify that your ballot was included and counted correctly using your receipt, but you cannot prove to anyone else how you voted (this is by design to prevent vote selling/coercion).

### Q: What if verification fails?

**A**: If verification fails:
1. Re-download the verification package (may have been corrupted)
2. Try verification on a different machine
3. If still failing, report to election officials
4. Failed verification does not necessarily mean fraud - it could be a technical issue

### Q: How long does verification take?

**A**: Typical verification times on consumer hardware:
- Single ballot proof: ~5ms
- 100,000 ballot proofs: ~8 minutes
- Full election verification: ~15-30 minutes

### Q: Can I verify without downloading everything?

**A**: Yes, you can:
- Verify specific ballots by ID
- Verify a random sample of proofs
- Verify only the tally correctness proof

### Q: What hardware do I need?

**A**: Minimum requirements:
- Any modern computer (2015 or newer)
- 4 GB RAM
- 1 GB free disk space
- Internet connection (for downloading)

### Q: Is the verification software trustworthy?

**A**: The verification software is:
- Open source (audit the code yourself)
- Deterministic (same inputs always produce same outputs)
- Reproducible (build from source)
- Multiple implementations available (cross-verify)

### Q: What if I find a problem?

**A**: If you discover a verification issue:
1. Document the exact error message
2. Save all relevant files
3. Report to election officials
4. Contact independent auditors
5. Do NOT publicly disclose until investigated

## Technical Details

### Proof Verification Algorithms

#### Bulletproof Verification

```
1. Parse proof components (A, S, T1, T2, τx, μ, t̂, L[], R[])
2. Compute challenges using Fiat-Shamir heuristic
3. Verify inner product argument
4. Check range constraint: 0 ≤ v < 2^n
5. Return valid if all checks pass
```

#### Groth16 Verification

```
1. Parse proof (A, B, C) and public inputs
2. Compute pairing: e(A, B)
3. Verify: e(A, B) = e(α, β) · e(∑ᵢ aᵢ·ICᵢ, γ) · e(C, δ)
4. Return valid if pairing equation holds
```

#### PLONK Verification

```
1. Parse proof and public inputs
2. Compute challenges (β, γ, α, ζ)
3. Verify polynomial commitments
4. Check linearization polynomial
5. Verify KZG opening proofs
6. Return valid if all checks pass
```

### Cryptographic Parameters

| Parameter | Value | Description |
|-----------|-------|-------------|
| Security Level | 128 bits | Computational security |
| Curve | BLS12-381 | Pairing-friendly curve |
| Hash | SHA-256 | Fiat-Shamir challenges |
| Field Size | 255 bits | Scalar field |

## Resources

- [Bulletproofs Paper](https://eprint.iacr.org/2017/1066)
- [Groth16 Paper](https://eprint.iacr.org/2016/260)
- [PLONK Paper](https://eprint.iacr.org/2019/953)
- [Source Code](https://github.com/Digital-Defiance/node-fhe-accelerate)
- [npm Package](https://www.npmjs.com/package/@digitaldefiance/node-fhe-accelerate)
